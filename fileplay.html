<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
  <style>
    .control-btn {
      padding: 10px 20px;
      background: #007cba;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .control-btn:hover {
      background: #005a87;
    }
    #connection-panel {
      transition: all 0.3s ease;
    }
    .connected {
      background: #d4edda !important;
      border: 1px solid #c3e6cb;
    }

    /* Connection indicator styles */
    .indicator-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
      animation: pulse 2s infinite;
    }

    .indicator-dot.connected {
      background-color: #28a745;
    }

    .indicator-dot.connecting {
      background-color: #ffc107;
    }

    .indicator-dot.disconnected {
      background-color: #dc3545;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    /* Chat message styles */
    .chat-message {
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 8px;
      word-wrap: break-word;
    }

    .chat-message.own {
      background: #007cba;
      color: white;
      margin-left: 20%;
      text-align: right;
    }

    .chat-message.other {
      background: #e9ecef;
      color: #333;
      margin-right: 20%;
    }

    .chat-username {
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 3px;
      opacity: 0.8;
    }

    .chat-text {
      font-size: 14px;
    }

    .chat-time {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 3px;
    }

    /* Notification styles */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #007cba;
      color: white;
      padding: 15px 20px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      animation: slideIn 0.3s ease;
      max-width: 300px;
    }

    .notification.error {
      background: #dc3545;
    }

    .notification.warning {
      background: #ffc107;
      color: #333;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    /* URL input styles */
    #url-input-container {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    #video-url-input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    #video-url-input:focus {
      outline: none;
      border-color: #007cba;
    }

    /* Source type indicator */
    .source-type-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      margin-left: 10px;
    }

    .source-type-badge.youtube {
      background: #ff0000;
      color: white;
    }

    .source-type-badge.url {
      background: #17a2b8;
      color: white;
    }

    .source-type-badge.local {
      background: #6c757d;
      color: white;
    }

    /* Loading indicator */
    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #007cba;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Webcam specific styles */
    .peer-video-container { 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      position: relative;
      flex-shrink: 0;
      width: 160px;
      height: 90px;
      aspect-ratio: 16 / 9;
      overflow: hidden;
      z-index: 10;
    }

    .peer-video-container video { 
      width: 100%;
      height: 100%;
      background-color: #222;
      border-radius: 4px;
      transform: scaleX(-1);
      object-fit: cover;
      aspect-ratio: 16 / 9;
    }

    /* When webcam area is large in fullscreen */
    #video-chat-wrapper:fullscreen #webcam-container.large-view .peer-video-container {
      width: auto;
      height: auto;
      aspect-ratio: 16 / 9;
      flex: 0 0 auto;
      z-index: 10;
    }

    #video-chat-wrapper:fullscreen #webcam-container.large-view .peer-video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      aspect-ratio: 16 / 9;
    }

    /* Single webcam in large view */
    #video-chat-wrapper:fullscreen #webcam-container.large-view .peer-video-container:only-child {
      width: calc(80vw - 20px);
      height: calc((80vw - 20px) / (16 / 9));
      aspect-ratio: 16 / 9;
    }

    .user-label {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 15;
    }

    .peer-video-container:hover .user-label {
      opacity: 1;
    }

    #webcam-container.large-view .user-label {
      font-size: 16px;
      padding: 6px 12px;
      top: 10px;
      left: 10px;
      opacity: 0.8;
    }

    #webcam-container.large-view .peer-video-container:hover .user-label {
      opacity: 1;
    }

    /* Volume control styles */
    .volume-control {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 16;
    }

    .peer-video-container:hover .volume-control {
      opacity: 1;
    }

    .volume-icon {
      width: 16px;
      height: 16px;
      fill: white;
      cursor: pointer;
      flex-shrink: 0;
    }

    .volume-slider {
      width: 80px;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
    }

    .volume-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    /* Larger volume controls for large view */
    #webcam-container.large-view .volume-control {
      padding: 8px 15px;
      bottom: 15px;
    }

    #webcam-container.large-view .volume-icon {
      width: 20px;
      height: 20px;
    }

    #webcam-container.large-view .volume-slider {
      width: 120px;
      height: 6px;
    }

    #webcam-container.large-view .volume-slider::-webkit-slider-thumb {
      width: 16px;
      height: 16px;
    }

    #webcam-container.large-view .volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
    }

    /* Webcam controls positioning */
    #webcam-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 100;
    }

    #video-chat-wrapper:fullscreen #webcam-controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
    }

    .webcam-control-btn {
      all: unset;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      box-sizing: border-box;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
      backdrop-filter: blur(10px);
      flex-shrink: 0;
    }

    .webcam-control-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .webcam-control-btn.active {
      background: rgba(0, 123, 202, 0.6) !important;
    }

    .webcam-control-btn:not(.active) {
      background: rgba(255, 255, 255, 0.2);
    }

    .webcam-control-btn.ptt-active {
      background: rgba(0, 200, 83, 0.6) !important;
    }

    .webcam-control-btn svg {
      width: 20px;
      height: 20px;
    }

    .webcam-control-btn svg path {
      fill: white;
    }

    #minimized-webcam {
      position: absolute;
      bottom: 15px;
      left: 15px;
      width: 160px;
      height: 90px;
      background: #222;
      border-radius: 8px;
      overflow: hidden;
      display: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 9;
      cursor: pointer;
      aspect-ratio: 16 / 9;
    }

    #video-chat-wrapper:fullscreen #minimized-webcam {
      position: fixed;
      bottom: 10px;
      left: 10px;
    }

    #minimized-webcam video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      aspect-ratio: 16 / 9;
    }

    .plyr__control[data-plyr="fullscreen"] { display: none !important; }

    #video-chat-wrapper:fullscreen { 
      display: flex; 
      flex-direction: column; 
      background-color: #000; 
      height: 100vh;
    }

    #video-chat-wrapper:fullscreen #video-player-container { 
      flex-grow: 0; 
      flex-shrink: 0;
      min-height: 0; 
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #video-chat-wrapper:fullscreen #video-player-container .plyr {
      width: 100%;
      height: 100%;
    }

    #video-chat-wrapper:fullscreen .plyr__video-wrapper { 
      pointer-events: none; 
      height: 100%;
    }

    #video-chat-wrapper:fullscreen .plyr video {
      height: 100%;
      width: 100%;
      object-fit: contain;
    }

    #video-chat-wrapper:fullscreen #webcam-container {
      flex-grow: 0;
      flex-shrink: 0;
      overflow-x: auto;
      overflow-y: hidden;
      flex-wrap: nowrap;
      background: #000;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #video-chat-wrapper:fullscreen #webcam-container.large-view {
      flex-wrap: wrap;
      justify-content: center;
      align-content: center;
      overflow-y: auto;
      gap: 20px;
      padding: 10px;
    }

    #video-chat-wrapper:fullscreen #webcam-container::-webkit-scrollbar {
      height: 6px;
      width: 6px;
    }

    #video-chat-wrapper:fullscreen #webcam-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    #video-chat-wrapper:fullscreen #webcam-container::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    #video-chat-wrapper:fullscreen #webcam-container::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    #fullscreen-divider {
      height: 8px;
      cursor: row-resize;
      background-color: transparent;
      position: relative;
      flex-shrink: 0;
      z-index: 99999;
      transition: background-color 0.2s ease;
    }

    #fullscreen-divider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-50%);
      transition: all 0.2s ease;
    }

    #fullscreen-divider::after {
      content: '⋮';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.6);
      font-size: 16px;
      line-height: 1;
      transition: color 0.2s ease;
    }

    #fullscreen-divider:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    #fullscreen-divider:hover::before {
      background-color: rgba(255, 255, 255, 0.8);
      height: 2px;
    }

    #fullscreen-divider:hover::after {
      color: rgba(255, 255, 255, 1);
    }

    #webcam-container.collapsed {
      display: none;
    }

    @media (max-width: 768px) {
      #watch-room-container > div:last-child {
        flex-direction: column;
      }
      
      #chat-container {
        width: 100% !important;
        height: 400px;
        margin-top: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="watch-room-container" style="max-width: 1400px; margin: 0 auto; padding: 20px;">
    <div id="connection-panel" style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <div style="display: flex; align-items: center;">
          <strong>Logged in as:</strong> <span id="my-username" style="margin-left: 5px;"></span>
          <div id="connection-indicator" style="display: inline-block; margin-left: 15px;">
            <span class="indicator-dot disconnected"></span>
            <span id="connection-label">Connecting...</span>
          </div>
        </div>
        <div>
          <strong>Room:</strong> <span id="room-status">Initializing...</span>
        </div>
      </div>
      <div id="users-list" style="margin-top: 10px;">
        <strong>Online Users:</strong>
        <div id="online-users" style="margin-top: 5px;">
          <span style="color: #666;">Waiting for connections...</span>
        </div>
      </div>
    </div>
    
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
      <div style="flex: 1; min-width: 300px;">
        <div id="video-chat-wrapper" style="background: #000; border-radius: 8px; position: relative;">
          <div id="video-player-container" style="padding: 20px;">
            <video id="sync-player" controls crossorigin playsinline>
              <source src="" type="video/mp4">
            </video>
          </div>
          
          <div id="webcam-container" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; background: #000; justify-content: center; align-items: center; min-height: 90px; position: relative;">
            <div id="local-video-container" class="peer-video-container">
              <video id="local-video" muted autoplay playsinline></video>
              <span class="user-label">Me</span>
            </div>
          </div>
          
          <div id="fullscreen-divider" style="display: none;"></div>
          
          <div id="webcam-controls">
            <button id="camera-toggle" class="webcam-control-btn active" title="Toggle Camera">
              <svg viewBox="0 0 24 24">
                <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
              </svg>
            </button>
            <button id="audio-toggle" class="webcam-control-btn active" title="Toggle Audio (Hold Spacebar for push-to-talk)">
              <svg viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
              </svg>
            </button>
            <button id="minimize-toggle" class="webcam-control-btn" title="Minimize Webcam">
              <svg viewBox="0 0 24 24">
                <path d="M6 19h12v2H6z"/>
              </svg>
            </button>
          </div>
          
          <div id="minimized-webcam">
            <video id="minimized-video" muted autoplay playsinline></video>
          </div>
        </div>
        
        <div id="file-controls" style="margin-top: 20px;">
          <div id="url-input-container">
            <input type="text" id="video-url-input" placeholder="Enter YouTube URL or direct video link (mp4, webm, ogg, mkv)">
            <button id="load-url-btn" class="control-btn">Load URL</button>
          </div>
          <div style="text-align: center;">
            <button id="load-video-btn" class="control-btn">Load Video File</button>
            <button id="load-subtitle-btn" class="control-btn">Load Subtitle</button>
            <span id="filename-display" style="margin-left: 20px; color: #666;"></span>
          </div>
          <div id="subtitle-status" style="margin-top: 10px; font-size: 14px; color: #666; text-align: center;">
            <span id="subtitle-info">No subtitle loaded</span>
          </div>
          <input type="file" id="video-input" accept="video/*,.mkv" style="display: none;">
          <input type="file" id="subtitle-input" accept=".srt,.vtt" style="display: none;">
        </div>
        
        <div id="sync-status" style="margin-top: 10px; text-align: center; color: #666;">
          Status: <span id="status-text">Ready</span>
        </div>
      </div>
      
      <div id="chat-container" style="width: 350px; background: #f8f9fa; border-radius: 8px; padding: 15px; display: flex; flex-direction: column; height: 500px;">
        <h3 style="margin: 0 0 15px 0; padding-bottom: 10px; border-bottom: 2px solid #dee2e6;">Chat</h3>
        
        <div id="chat-messages" style="flex: 1; overflow-y: auto; background: white; border-radius: 5px; padding: 10px; margin-bottom: 15px;">
          <div style="color: #666; text-align: center; padding: 20px;">No messages yet</div>
        </div>
        
        <div style="display: flex; gap: 10px;">
          <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
          <button id="send-btn" class="control-btn" style="padding: 10px 20px;">Send</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Initializing Enhanced Video Sync System...');
      
      // CONFIGURATION
      const ROOM_ID = 'Private';
      const AUTHORIZED_USERS = ['Kuljeet', 'Srushti'];
      
      // SOURCE MANAGEMENT VARIABLES
      let currentSourceType = null; // 'local', 'youtube', 'url'
      let currentSourceIdentifier = null; // filename, youtube ID, or URL
      let youtubePlayer = null; // Store YouTube player instance
      let isYouTubeReady = false;
      
      // WEBCAM VARIABLES
      let localStream = null;
      let isMinimized = false;
      let isCameraOn = true;
      let isAudioOn = true;
      let isPushToTalk = false;
      let isSpacebarPressed = false;
      const peerMediaConnections = new Map();
      const userVolumes = new Map(); // Store volume preferences for each user
      
      // NOTIFICATION SOUND
      function playNotificationSound() {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }
      
      // NOTIFICATION SYSTEM
      function showNotification(title, message, duration = 5000, type = '') {
        const notification = document.createElement('div');
        notification.className = 'notification' + (type ? ' ' + type : '');
        notification.innerHTML = `
          <strong>${title}</strong><br>
          ${message}
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.animation = 'slideOut 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }, duration);
      }
      
      // SOURCE TYPE DETECTION
      function detectSourceType(input) {
        // YouTube detection
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const youtubeMatch = input.match(youtubeRegex);
        
        if (youtubeMatch) {
          return {
            type: 'youtube',
            identifier: youtubeMatch[1]
          };
        }
        
        // Direct URL detection
        if (input.startsWith('http://') || input.startsWith('https://')) {
          const videoExtensions = ['.mp4', '.webm', '.ogg', '.mkv'];
          const hasVideoExtension = videoExtensions.some(ext => input.toLowerCase().includes(ext));
          
          if (hasVideoExtension || input.includes('video')) {
            return {
              type: 'url',
              identifier: input
            };
          }
        }
        
        return null;
      }
      
      // CHECK URL ACCESSIBILITY
      async function checkUrlAccessibility(url) {
        try {
          const response = await fetch(url, { 
            method: 'HEAD',
            mode: 'cors'
          });
          return response.ok;
        } catch (error) {
          // Try with no-cors as fallback
          try {
            const response = await fetch(url, { 
              method: 'HEAD',
              mode: 'no-cors'
            });
            // no-cors doesn't give us status, but if it doesn't throw, URL exists
            return true;
          } catch {
            return false;
          }
        }
      }
      
      // MKV COMPATIBILITY CHECK
      function checkMkvSupport() {
        const video = document.createElement('video');
        return video.canPlayType('video/x-matroska') !== '' || 
               video.canPlayType('video/webm') !== '';
      }
      
      // UPDATE SOURCE TYPE BADGE
      function updateSourceTypeBadge(type, identifier) {
        const existingBadge = document.querySelector('.source-type-badge');
        if (existingBadge) existingBadge.remove();
        
        if (!type) return;
        
        const badge = document.createElement('span');
        badge.className = `source-type-badge ${type}`;
        
        switch(type) {
          case 'youtube':
            badge.textContent = 'YouTube';
            break;
          case 'url':
            badge.textContent = 'Direct URL';
            break;
          case 'local':
            badge.textContent = 'Local File';
            break;
        }
        
        document.getElementById('filename-display').appendChild(badge);
      }
      
      // LOAD SOURCE FUNCTION
      async function loadSource(type, identifier, fromUser = null) {
        currentSourceType = type;
        currentSourceIdentifier = identifier;
        
        document.getElementById('status-text').innerHTML = '<span class="loading-spinner"></span> Loading...';
        
        try {
          switch(type) {
            case 'youtube':
              loadYouTubeVideo(identifier);
              document.getElementById('filename-display').textContent = `YouTube: ${identifier}`;
              updateSourceTypeBadge('youtube', identifier);
              if (fromUser) {
                showNotification('YouTube Video', `${fromUser} loaded a YouTube video`, 3000);
              }
              break;
              
            case 'url':
              const accessible = await checkUrlAccessibility(identifier);
              if (!accessible) {
                throw new Error('URL is not accessible. It may be blocked by CORS or unavailable.');
              }
              
              // Check for MKV
              if (identifier.toLowerCase().includes('.mkv')) {
                if (!checkMkvSupport()) {
                  showNotification('MKV Warning', 'MKV files may not play in all browsers. Chrome has better support than Firefox.', 5000, 'warning');
                }
              }
              
              loadDirectUrl(identifier);
              const filename = identifier.split('/').pop();
              document.getElementById('filename-display').textContent = filename;
              updateSourceTypeBadge('url', identifier);
              if (fromUser) {
                showNotification('Direct URL', `${fromUser} loaded: ${filename}`, 3000);
              }
              break;
              
            case 'local':
              // For local files, request file from the user who shared it
              if (fromUser) {
                document.getElementById('filename-display').textContent = `Requesting: ${identifier}`;
                showNotification('File Request', `Requesting "${identifier}" from ${fromUser}`, 3000);
                // In a real implementation, you'd implement WebRTC file transfer here
              }
              break;
          }
          
          document.getElementById('status-text').textContent = 'Ready';
          
        } catch (error) {
          console.error('Error loading source:', error);
          showNotification('Load Error', error.message, 5000, 'error');
          document.getElementById('status-text').textContent = 'Error loading source';
        }
      }
      
      // LOAD YOUTUBE VIDEO
      function loadYouTubeVideo(videoId) {
        player.source = {
          type: 'video',
          sources: [{
            src: videoId,
            provider: 'youtube'
          }]
        };
        
        // Wait for YouTube player to be ready
        isYouTubeReady = false;
        const checkYouTubeReady = setInterval(() => {
          const iframe = document.querySelector('.plyr__video-embed iframe');
          if (iframe && iframe.contentWindow) {
            clearInterval(checkYouTubeReady);
            isYouTubeReady = true;
            console.log('YouTube player ready');
          }
        }, 100);
      }
      
      // LOAD DIRECT URL
      function loadDirectUrl(url) {
        // Determine video type from URL
        let videoType = 'video/mp4'; // default
        if (url.includes('.webm')) videoType = 'video/webm';
        else if (url.includes('.ogg')) videoType = 'video/ogg';
        else if (url.includes('.mkv')) videoType = 'video/x-matroska';
        
        player.source = {
          type: 'video',
          sources: [{
            src: url,
            type: videoType
          }],
          tracks: currentSubtitleURL ? [{
            kind: 'captions',
            label: 'English',
            srclang: 'en',
            src: currentSubtitleURL,
            default: true
          }] : []
        };
      }
      
      // PLYR PLAYER INITIALIZATION
      const videoChatWrapper = document.getElementById('video-chat-wrapper');
      const videoPlayerContainer = document.getElementById('video-player-container');
      const webcamContainer = document.getElementById('webcam-container');
      const fullscreenDivider = document.getElementById('fullscreen-divider');
      const localVideo = document.getElementById('local-video');
      const localVideoContainer = document.getElementById('local-video-container');
      const minimizedWebcam = document.getElementById('minimized-webcam');
      const minimizedVideo = document.getElementById('minimized-video');
      
      const audioToggle = document.getElementById('audio-toggle');
      const cameraToggle = document.getElementById('camera-toggle');
      const minimizeToggle = document.getElementById('minimize-toggle');
      
      const player = new Plyr('#sync-player', {
        controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay'],
        settings: ['captions', 'quality', 'speed'],
        speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 2] },
        keyboard: { focused: false, global: false },
        captions: { active: false, language: 'en', update: true },
        youtube: { 
          noCookie: true,
          rel: 0,
          showinfo: 0,
          iv_load_policy: 3,
          modestbranding: 1,
          // Important: force playback through API
          playsinline: 1,
          controls: 0
        }
      });
      
      window.syncPlayer = player;
      
      // URL INPUT HANDLING
      const urlInput = document.getElementById('video-url-input');
      const loadUrlBtn = document.getElementById('load-url-btn');
      
      loadUrlBtn.addEventListener('click', async () => {
        const url = urlInput.value.trim();
        if (!url) return;
        
        const source = detectSourceType(url);
        if (!source) {
          showNotification('Invalid URL', 'Please enter a valid YouTube URL or direct video link', 3000, 'error');
          return;
        }
        
        await loadSource(source.type, source.identifier);
        
        // Share with all connected users
        if (connections.size > 0) {
          sendToAll({
            type: 'source-changed',
            sourceType: source.type,
            sourceIdentifier: source.identifier,
            fromUser: myUsername
          });
        }
        
        urlInput.value = '';
      });
      
      urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          loadUrlBtn.click();
        }
      });
      
      // WEBCAM INITIALIZATION
      async function setupLocalMedia() {
        try {
          // Enhanced audio quality settings
          const mediaConstraints = { 
            video: {
              aspectRatio: { exact: 16 / 9 },
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            }, 
            audio: {
              // High quality but practical for voice chat
              sampleRate: { ideal: 48000 },        // 48kHz (standard high quality)
              channelCount: { ideal: 1 },          // Mono (sufficient for voice, saves bandwidth)
              
              // Keep these ON for better voice chat experience
              echoCancellation: { ideal: true },   // Essential for speakers
              noiseSuppression: { ideal: true },   // Reduces background noise
              autoGainControl: { ideal: true },    // Normalizes voice levels
            }
          };

          localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
          localVideo.srcObject = localStream;
          minimizedVideo.srcObject = localStream;
          
          connections.forEach((dataConn, username) => {
            if (peer && localStream) {
              const call = peer.call(dataConn.peer, localStream);
              if (call) {
                peerMediaConnections.set(username, call);
                // Optimize audio bitrate for the call
                optimizeAudioBitrate(call.peerConnection);
              }
            }
          });
        } catch (err) { 
          console.error("Failed to get local stream", err);
          
          // Fallback to basic audio if high-quality fails
          try {
            const fallbackConstraints = {
              video: {
                aspectRatio: { exact: 16 / 9 },
                width: { ideal: 1920 },
                height: { ideal: 1080 }
              },
              audio: true
            };
            localStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
            localVideo.srcObject = localStream;
            minimizedVideo.srcObject = localStream;
            showNotification('Audio Notice', 'Using default audio settings', 3000, 'warning');
          } catch (fallbackErr) {
            showNotification('Camera Error', 'Failed to access camera/microphone', 3000, 'error');
          }
        }
      }
      
      // OPTIMIZE AUDIO BITRATE FOR PEER CONNECTIONS
      function optimizeAudioBitrate(peerConnection) {
        if (!peerConnection) return;
        
        peerConnection.getSenders().forEach(sender => {
          if (sender.track?.kind === 'audio') {
            const params = sender.getParameters();
            if (params.encodings && params.encodings[0]) {
              params.encodings[0].maxBitrate = 128000; // 128 kbps for voice
              sender.setParameters(params).catch(e => console.log('Bitrate setting failed:', e));
            }
          }
        });
      }
      
      setupLocalMedia();
      
      // WEBCAM CONTROLS
      function updateMicState() {
        if (localStream) {
          const audioTracks = localStream.getAudioTracks();
          if (isPushToTalk) {
            audioTracks.forEach(track => {
              track.enabled = isSpacebarPressed;
            });
            audioToggle.classList.toggle('ptt-active', isSpacebarPressed);
            audioToggle.classList.remove('active');
          } else {
            audioTracks.forEach(track => {
              track.enabled = isAudioOn;
            });
            audioToggle.classList.toggle('active', isAudioOn);
            audioToggle.classList.remove('ptt-active');
          }
        }
      }

      audioToggle.addEventListener('click', () => {
        if (localStream) {
          if (isPushToTalk) {
            // If in push-to-talk mode, switch to always on
            isPushToTalk = false;
            isAudioOn = true;
            updateMicState();
            audioToggle.querySelector('path').setAttribute('d', 'M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z');
            showNotification('Audio On', 'Microphone is always on', 1500);
          } else {
            // If in always on/off mode, toggle the state
            isAudioOn = !isAudioOn;
            updateMicState();
            if (isAudioOn) {
              audioToggle.querySelector('path').setAttribute('d', 'M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z');
              showNotification('Audio On', 'Microphone is always on', 1500);
            } else {
              audioToggle.querySelector('path').setAttribute('d', 'M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z');
              showNotification('Audio Off', 'Microphone is muted', 1500);
            }
          }
        }
      });
      
      cameraToggle.addEventListener('click', () => {
        if (localStream) {
          isCameraOn = !isCameraOn;
          localStream.getVideoTracks().forEach(track => {
            track.enabled = isCameraOn;
          });
          cameraToggle.classList.toggle('active', isCameraOn);
          if (isCameraOn) {
            cameraToggle.querySelector('path').setAttribute('d', 'M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z');
          } else {
            cameraToggle.querySelector('path').setAttribute('d', 'M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z');
          }
        }
      });
      
      minimizeToggle.addEventListener('click', () => {
        isMinimized = !isMinimized;
        if (isMinimized) {
          localVideoContainer.style.display = 'none';
          minimizedWebcam.style.display = 'block';
          minimizeToggle.querySelector('path').setAttribute('d', 'M7 14l5-5 5 5z');
        } else {
          localVideoContainer.style.display = 'flex';
          minimizedWebcam.style.display = 'none';
          minimizeToggle.querySelector('path').setAttribute('d', 'M6 19h12v2H6z');
        }
        updateFullscreenLayout(parseInt(webcamContainer.style.height) || 150, false);
      });
      
      minimizedWebcam.addEventListener('click', () => {
        isMinimized = false;
        localVideoContainer.style.display = 'flex';
        minimizedWebcam.style.display = 'none';
        minimizeToggle.querySelector('path').setAttribute('d', 'M6 19h12v2H6z');
        updateFullscreenLayout(parseInt(webcamContainer.style.height) || 150, false);
      });

      // PUSH-TO-TALK FUNCTIONALITY
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !e.repeat && document.activeElement !== document.getElementById('chat-input')) {
          e.preventDefault();
          
          // Automatically switch to push-to-talk mode if not already in it
          if (!isPushToTalk) {
            isPushToTalk = true;
            isAudioOn = false;
            showNotification('Push-to-Talk Activated', 'Hold spacebar to talk', 1500);
          }
          
          isSpacebarPressed = true;
          updateMicState();
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && document.activeElement !== document.getElementById('chat-input')) {
          e.preventDefault();
          isSpacebarPressed = false;
          updateMicState();
        }
      });
      
      // FULLSCREEN FUNCTIONALITY
      let customFullscreenBtn;
      
      player.on('ready', () => {
        const controls = document.querySelector('.plyr__controls');
        if (!controls) return;

        customFullscreenBtn = document.createElement('button');
        customFullscreenBtn.type = 'button';
        customFullscreenBtn.className = 'plyr__control';
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('role', 'presentation');
        svg.setAttribute('focusable', 'false');
        svg.setAttribute('viewBox', '0 0 24 24');
        
        const fullscreenIconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        fullscreenIconPath.setAttribute('d', 'M15 3h6v6h-2V5h-4V3zM9 21H3v-6h2v4h4v2zm12-6h-2v4h-4v2h6v-6zM3 9V3h6v2H5v4H3z');
        fullscreenIconPath.style.fill = 'white';

        svg.appendChild(fullscreenIconPath);
        customFullscreenBtn.appendChild(svg);
        
        customFullscreenBtn.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            videoChatWrapper.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          customFullscreenBtn.blur();
        });
        
        controls.appendChild(customFullscreenBtn);

        videoChatWrapper.addEventListener('fullscreenchange', () => {
          const isFullscreen = !!document.fullscreenElement;
          
          const newPath = isFullscreen 
            ? 'M3 15h6v6H3v-6zM3 3h6v6H3V3zm12 0h6v6h-6V3zm0 12h6v6h-6v-6z'
            : 'M15 3h6v6h-2V5h-4V3zM9 21H3v-6h2v4h4v2zm12-6h-2v4h-4v2h6v-6zM3 9V3h6v2H5v4H3z';
          fullscreenIconPath.setAttribute('d', newPath);

          if (isFullscreen) {
            fullscreenDivider.style.display = 'block';
            videoChatWrapper.appendChild(fullscreenDivider);
            videoChatWrapper.appendChild(webcamContainer);
            videoChatWrapper.appendChild(document.getElementById('webcam-controls'));
            videoChatWrapper.appendChild(minimizedWebcam);
            
            const initialWebcamHeight = 150;
            const initialVideoHeight = window.innerHeight - initialWebcamHeight - 8;
            videoPlayerContainer.style.height = `${initialVideoHeight}px`;
            webcamContainer.style.height = `${initialWebcamHeight}px`;
            updateFullscreenLayout(initialWebcamHeight, false);
            
            showNotification('Fullscreen Controls', 'Drag divider to resize • Double-click to toggle • Press "W" for webcam focus • Hold Spacebar to talk', 4000);
          } else {
            fullscreenDivider.style.display = 'none';
            videoPlayerContainer.insertAdjacentElement('afterend', webcamContainer);
            webcamContainer.style.flexBasis = '';
            webcamContainer.style.height = '';
            videoPlayerContainer.style.height = '';
            webcamContainer.style.display = 'flex';
            webcamContainer.classList.remove('collapsed');
            webcamContainer.classList.remove('large-view');
            videoPlayerContainer.classList.remove('minimal');
            webcamContainer.querySelectorAll('.peer-video-container').forEach(container => {
              container.style.width = '160px';
              container.style.height = '90px';
            });
          }
        });
      });

      function updateFullscreenLayout(newWebcamBarHeight, animate = false) {
        if (animate) {
          videoPlayerContainer.style.transition = 'height 0.3s ease-out';
          webcamContainer.style.transition = 'height 0.3s ease-out';
          setTimeout(() => {
            videoPlayerContainer.style.transition = '';
            webcamContainer.style.transition = '';
          }, 300);
        }
        
        if (newWebcamBarHeight <= 8) {
          webcamContainer.style.display = 'none';
          webcamContainer.classList.add('collapsed');
          videoPlayerContainer.style.height = 'calc(100vh - 8px)';
          videoPlayerContainer.classList.remove('minimal');
          webcamContainer.classList.remove('large-view');
          return;
        }
        
        webcamContainer.style.display = 'flex';
        webcamContainer.classList.remove('collapsed');
        
        const minWebcamHeight = 90;
        const minVideoHeight = 50;
        
        if (newWebcamBarHeight < minWebcamHeight) {
          newWebcamBarHeight = minWebcamHeight;
        }
        
        let videoPlayerHeight = window.innerHeight - newWebcamBarHeight - 8;
        
        if (videoPlayerHeight < minVideoHeight) {
          videoPlayerHeight = minVideoHeight;
          newWebcamBarHeight = window.innerHeight - videoPlayerHeight - 8;
        }
        
        videoPlayerContainer.style.height = `${videoPlayerHeight}px`;
        webcamContainer.style.height = `${newWebcamBarHeight}px`;
        webcamContainer.style.flexBasis = 'auto';
        
        if (videoPlayerHeight <= 100) {
          videoPlayerContainer.classList.add('minimal');
        } else {
          videoPlayerContainer.classList.remove('minimal');
        }
        
        const webcamPadding = 10;
        const availableHeight = newWebcamBarHeight - webcamPadding * 2;
        const aspectRatio = 16 / 9;
        const numWebcams = Array.from(webcamContainer.querySelectorAll('.peer-video-container')).filter(
          container => container.style.display !== 'none'
        ).length;
        
        webcamContainer.classList.toggle('large-view', newWebcamBarHeight > window.innerHeight * 0.4);
        
        webcamContainer.querySelectorAll('.peer-video-container').forEach(container => {
          if (container.style.display === 'none') return;
          
          let containerHeight, containerWidth;
          if (newWebcamBarHeight > window.innerHeight * 0.4) {
            if (numWebcams === 1) {
              containerHeight = Math.min(availableHeight, window.innerHeight - 50);
              containerWidth = containerHeight * aspectRatio;
              containerWidth = Math.min(containerWidth, window.innerWidth * 0.8 - 20);
              containerHeight = containerWidth / aspectRatio;
            } else {
              const maxColumns = Math.ceil(Math.sqrt(numWebcams));
              containerHeight = Math.min(availableHeight / maxColumns, (window.innerHeight - 50) / maxColumns);
              containerWidth = containerHeight * aspectRatio;
              containerWidth = Math.min(containerWidth, (window.innerWidth - 20 * maxColumns) / maxColumns);
              containerHeight = containerWidth / aspectRatio;
            }
          } else {
            containerHeight = availableHeight;
            containerWidth = containerHeight * aspectRatio;
          }
          
          container.style.width = `${containerWidth}px`;
          container.style.height = `${containerHeight}px`;
          
          const video = container.querySelector('video');
          video.style.objectFit = containerHeight > 720 ? 'cover' : 'contain';
        });
        
        if (window.syncPlayer) {
          window.syncPlayer.fullscreen.update();
        }
      }
      
      videoPlayerContainer.addEventListener('click', (e) => {
        if (!document.fullscreenElement || !videoPlayerContainer.classList.contains('minimal')) return;
        
        if (e.target.closest('.plyr__controls')) return;
        
        e.preventDefault();
        updateFullscreenLayout(150, true);
        showNotification('View Restored', 'Normal video view', 1500);
      });
      
      fullscreenDivider.addEventListener('dblclick', (e) => {
        if (!document.fullscreenElement) return;
        e.preventDefault();
        
        const currentWebcamHeight = parseInt(webcamContainer.style.height) || 150;
        const isWebcamFocused = currentWebcamHeight > window.innerHeight * 0.4;
        
        if (isWebcamFocused) {
          updateFullscreenLayout(150, true);
        } else {
          updateFullscreenLayout(window.innerHeight - 58, true);
        }
      });
      
      let isDragging = false;
      fullscreenDivider.addEventListener('mousedown', (e) => {
        if (!document.fullscreenElement) return;
        e.preventDefault();
        isDragging = true;
        document.body.style.cursor = 'row-resize';
        document.body.style.userSelect = 'none';
        fullscreenDivider.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
      });
      
      window.addEventListener('mouseup', (e) => {
        if (isDragging) {
          e.preventDefault();
          isDragging = false;
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          fullscreenDivider.style.backgroundColor = '';
        }
      });

      window.addEventListener('mousemove', e => {
        if (!isDragging || !document.fullscreenElement) return;
        e.preventDefault();
        
        requestAnimationFrame(() => {
          let newWebcamBarHeight = window.innerHeight - e.clientY;
          updateFullscreenLayout(newWebcamBarHeight, false);
        });
      });
      
      // FILE LOADING FUNCTIONALITY
      const videoBtn = document.getElementById('load-video-btn');
      const subtitleBtn = document.getElementById('load-subtitle-btn');
      const videoInput = document.getElementById('video-input');
      const subtitleInput = document.getElementById('subtitle-input');
      
      let currentVideoURL = '';
      let currentSubtitleURL = '';
      let currentVideoName = '';
      
      videoBtn.addEventListener('click', () => videoInput.click());
      subtitleBtn.addEventListener('click', () => subtitleInput.click());
      
      function srtToVtt(srt) {
        const vtt = srt.replace(/(\d+)\r?\n(\d{2}:\d{2}:\d{2}),(\d{3}) --> (\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1\n$2.$3 --> $4.$5');
        return 'WEBVTT\n\n' + vtt;
      }
      
      videoInput.addEventListener('change', async function(e) {
        if (e.target.files[0]) {
          const file = e.target.files[0];
          
          // Check for MKV files
          if (file.name.toLowerCase().endsWith('.mkv')) {
            if (!checkMkvSupport()) {
              showNotification('MKV Warning', 'MKV files may not play in your browser. Chrome has better support than Firefox. The file will still be loaded.', 5000, 'warning');
            }
          }
          
          currentVideoURL = URL.createObjectURL(file);
          currentVideoName = file.name;
          currentSourceType = 'local';
          currentSourceIdentifier = file.name;
          
          updatePlayerSource();
          document.getElementById('status-text').textContent = 'Video loaded: ' + file.name;
          document.getElementById('filename-display').textContent = currentVideoName;
          updateSourceTypeBadge('local', file.name);
          
          if (connections.size > 0) {
            sendToAll({
              type: 'source-changed',
              sourceType: 'local',
              sourceIdentifier: file.name,
              fromUser: myUsername
            });
          }
        }
      });
      
      subtitleInput.addEventListener('change', async function(e) {
        if (e.target.files[0]) {
          const file = e.target.files[0];
          const text = await file.text();
          let processedContent = text;
          
          if (file.name.endsWith('.srt')) {
            processedContent = srtToVtt(text);
          }
          
          const blob = new Blob([processedContent], { type: 'text/vtt' });
          currentSubtitleURL = URL.createObjectURL(blob);
          
          updatePlayerSource();
          document.getElementById('status-text').textContent = 'Subtitle loaded: ' + file.name;
          document.getElementById('subtitle-info').textContent = `Subtitle: ${file.name} (local)`;
          
          if (connections.size > 0) {
            console.log('Sharing subtitle with connected users...');
            sendToAll({
              type: 'subtitle-loaded',
              filename: file.name,
              content: processedContent,
              fromUser: myUsername
            });
          }
        }
      });
      
      function updatePlayerSource() {
        if (!currentVideoURL && currentSourceType !== 'youtube' && currentSourceType !== 'url') return;
        
        if (currentSourceType === 'local') {
          const sourceConfig = {
            type: 'video',
            sources: [{
              src: currentVideoURL,
              type: 'video/mp4'
            }],
            tracks: []
          };
          
          if (currentSubtitleURL) {
            sourceConfig.tracks.push({
              kind: 'captions',
              label: 'English',
              srclang: 'en',
              src: currentSubtitleURL,
              default: true
            });
          }
          
          player.source = sourceConfig;
          
          if (currentSubtitleURL) {
            setTimeout(() => {
              player.captions.active = true;
            }, 500);
          }
        }
      }
      
      // CHAT FUNCTIONALITY
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const chatMessages = document.getElementById('chat-messages');
      
      function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        
        const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        addChatMessage(myUsername, message, timestamp, true);
        
        if (connections.size > 0) {
          sendToAll({
            type: 'chat-message',
            username: myUsername,
            message: message,
            timestamp: timestamp
          });
        }
        
        chatInput.value = '';
        chatInput.focus();
      }
      
      function addChatMessage(username, message, timestamp, isOwn = false) {
        if (chatMessages.querySelector('div[style*="No messages yet"]')) {
          chatMessages.innerHTML = '';
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isOwn ? 'own' : 'other'}`;
        messageDiv.innerHTML = `
          ${!isOwn ? `<div class="chat-username">${username}</div>` : ''}
          <div class="chat-text">${escapeHtml(message)}</div>
          <div class="chat-time">${timestamp}</div>
        `;
        
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
      
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      sendBtn.addEventListener('click', sendChatMessage);
      chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendChatMessage();
        }
      });
      
      // AUTO-CONNECT SYSTEM
      let peer = null;
      let connections = new Map();
      let isHost = false;
      let lastSentTime = 0;
      let lastSentState = '';
      let isReceivingRemote = false;
      let reconnectAttempts = 0;
      let reconnectTimer = null;
      let lastActivity = Date.now();
      
      const myUsername = (window.wpUserData && window.wpUserData.username) || 'User';
      document.getElementById('my-username').textContent = myUsername;
      
      document.addEventListener('click', () => lastActivity = Date.now());
      document.addEventListener('keypress', () => lastActivity = Date.now());
      document.addEventListener('mousemove', () => lastActivity = Date.now());
      
      async function initializeAutoConnect() {
        console.log('Initializing auto-connect for:', myUsername);
        
        try {
          peer = new Peer(ROOM_ID + '_' + myUsername);
        } catch (error) {
          console.error('Failed to create peer:', error);
          document.getElementById('room-status').textContent = 'Error - Check Console';
          updateConnectionIndicator('disconnected');
          return;
        }
        
        peer.on('open', function(id) {
          console.log('Connected to PeerJS with ID:', id);
          document.getElementById('room-status').textContent = ROOM_ID;
          connectToAllUsers();
        });
        
        peer.on('error', function(err) {
          console.error('PeerJS error:', err);
          if (err.type === 'unavailable-id') {
            document.getElementById('room-status').textContent = 'Already connected in another tab';
            updateConnectionIndicator('disconnected');
          }
        });
        
        peer.on('connection', function(conn) {
          console.log('Incoming connection from:', conn.peer);
          setupConnection(conn);
        });
        
        peer.on('call', function(call) {
          console.log('Incoming call from:', call.peer);
          
          if (localStream) {
            call.answer(localStream);
            setupMediaConnection(call);
            // Optimize audio bitrate for incoming calls
            optimizeAudioBitrate(call.peerConnection);
          } else {
            setTimeout(() => {
              if (localStream) {
                call.answer(localStream);
                setupMediaConnection(call);
                optimizeAudioBitrate(call.peerConnection);
              }
            }, 1000);
          }
        });
      }
      
      function setupMediaConnection(call) {
        const username = call.peer.replace(ROOM_ID + '_', '');
        
        call.on('stream', function(remoteStream) {
          console.log('Received remote stream from:', username);
          addRemoteVideo(username, remoteStream);
          updateFullscreenLayout(parseInt(webcamContainer.style.height) || 150, false);
        });
        
        call.on('close', function() {
          console.log('Media connection closed with:', username);
          removeRemoteVideo(username);
          updateFullscreenLayout(parseInt(webcamContainer.style.height) || 150, false);
        });
        
        call.on('error', function(err) {
          console.error('Media connection error with', username, ':', err);
        });
      }
      
      function createVolumeIcon(isMuted) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.classList.add('volume-icon');
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', isMuted 
          ? 'M7 9v6h4l5 5V4l-5 5H7z M18.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63z M21 12c0 .94-.2 1.82-.54 2.64l1.51 1.51C22.63 14.91 23 13.5 23 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71z M4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3z'
          : 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z'
        );
        
        svg.appendChild(path);
        return svg;
      }
      
      function addRemoteVideo(username, stream) {
        removeRemoteVideo(username);
        
        const videoContainer = document.createElement('div');
        videoContainer.className = 'peer-video-container';
        videoContainer.id = `video-${username}`;
        
        const video = document.createElement('video');
        video.autoplay = true;
        video.playsinline = true;
        video.srcObject = stream;
        
        // Get saved volume or default to 1 (100%)
        const savedVolume = userVolumes.get(username) || 1;
        video.volume = savedVolume;
        
        const label = document.createElement('span');
        label.className = 'user-label';
        label.textContent = username;
        
        // Create volume control
        const volumeControl = document.createElement('div');
        volumeControl.className = 'volume-control';
        
        const volumeIcon = createVolumeIcon(video.volume === 0);
        volumeIcon.addEventListener('click', () => {
          if (video.volume > 0) {
            video.volume = 0;
            volumeSlider.value = 0;
            volumeIcon.replaceWith(createVolumeIcon(true));
            volumeControl.querySelector('.volume-icon').addEventListener('click', arguments.callee);
          } else {
            video.volume = 1;
            volumeSlider.value = 1;
            volumeIcon.replaceWith(createVolumeIcon(false));
            volumeControl.querySelector('.volume-icon').addEventListener('click', arguments.callee);
          }
          userVolumes.set(username, video.volume);
        });
        
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.className = 'volume-slider';
        volumeSlider.min = '0';
        volumeSlider.max = '1';
        volumeSlider.step = '0.1';
        volumeSlider.value = savedVolume;
        
        volumeSlider.addEventListener('input', (e) => {
          const volume = parseFloat(e.target.value);
          video.volume = volume;
          userVolumes.set(username, volume);
          
          // Update volume icon
          const currentIcon = volumeControl.querySelector('.volume-icon');
          const newIcon = createVolumeIcon(volume === 0);
          newIcon.addEventListener('click', () => {
            if (video.volume > 0) {
              video.volume = 0;
              volumeSlider.value = 0;
              volumeControl.querySelector('.volume-icon').replaceWith(createVolumeIcon(true));
            } else {
              video.volume = 1;
              volumeSlider.value = 1;
              volumeControl.querySelector('.volume-icon').replaceWith(createVolumeIcon(false));
            }
            userVolumes.set(username, video.volume);
          });
          currentIcon.replaceWith(newIcon);
        });
        
        volumeControl.appendChild(volumeIcon);
        volumeControl.appendChild(volumeSlider);
        
        videoContainer.appendChild(video);
        videoContainer.appendChild(label);
        videoContainer.appendChild(volumeControl);
        webcamContainer.appendChild(videoContainer);
      }
      
      function removeRemoteVideo(username) {
        const existingVideo = document.getElementById(`video-${username}`);
        if (existingVideo) {
          existingVideo.remove();
        }
      }
      
      function connectToAllUsers() {
        if (Date.now() - lastActivity > 5 * 60 * 1000) {
          console.log('User inactive, pausing reconnection attempts');
          reconnectTimer = setTimeout(connectToAllUsers, 60000);
          return;
        }
        
        let newConnectionsMade = false;
        
        AUTHORIZED_USERS.forEach(username => {
          if (username !== myUsername && !connections.has(username)) {
            const targetId = ROOM_ID + '_' + username;
            
            try {
              const conn = peer.connect(targetId);
              setupConnection(conn);
              newConnectionsMade = true;
            } catch (error) {
              console.log('User offline:', username);
            }
          }
        });
        
        if (connections.size < AUTHORIZED_USERS.filter(u => u !== myUsername).length) {
          reconnectAttempts++;
          const delays = [5000, 10000, 20000, 40000, 60000];
          const delay = delays[Math.min(reconnectAttempts - 1, delays.length - 1)];
          console.log(`Scheduling reconnect attempt ${reconnectAttempts} in ${delay/1000}s`);
          reconnectTimer = setTimeout(connectToAllUsers, delay);
        } else {
          console.log('All users connected');
          reconnectAttempts = 0;
          clearTimeout(reconnectTimer);
        }
        
        updateConnectionIndicator();
      }
      
      function setupConnection(conn) {
        const username = conn.peer.replace(ROOM_ID + '_', '');
        
        conn.on('open', function() {
          console.log('Connected to:', username);
          connections.set(username, conn);
          updateOnlineUsersList();
          
          reconnectAttempts = 0;
          
          const connectedUsers = [myUsername, ...Array.from(connections.keys())].sort();
          isHost = (connectedUsers[0] === myUsername);
          console.log('Host status:', isHost ? 'Yes' : 'No');
          
          if (connections.size === 1) {
            startTimeSync();
          }
          
          // Share current source if any
          if (currentSourceType && currentSourceIdentifier) {
            sendToUser(conn, {
              type: 'source-changed',
              sourceType: currentSourceType,
              sourceIdentifier: currentSourceIdentifier,
              fromUser: myUsername
            });
          }
          
          if (peer && localStream) {
            setTimeout(() => {
              const call = peer.call(conn.peer, localStream);
              if (call) {
                peerMediaConnections.set(username, call);
                setupMediaConnection(call);
                // Optimize audio bitrate for outgoing calls
                optimizeAudioBitrate(call.peerConnection);
              }
            }, 500);
          }
        });
        
        conn.on('data', (data) => handleRemoteData(data, username));
        
        conn.on('close', function() {
          console.log('Disconnected from:', username);
          connections.delete(username);
          updateOnlineUsersList();
          
          const mediaConn = peerMediaConnections.get(username);
          if (mediaConn) {
            mediaConn.close();
            peerMediaConnections.delete(username);
          }
          removeRemoteVideo(username);
          
          if (connections.size === 0) {
            if (syncInterval) {
              clearInterval(syncInterval);
            }
          }
          
          reconnectAttempts = 0;
          clearTimeout(reconnectTimer);
          reconnectTimer = setTimeout(connectToAllUsers, 5000);
        });
      }
      
      function updateOnlineUsersList() {
        const onlineDiv = document.getElementById('online-users');
        const connectedUsers = Array.from(connections.keys());
        
        if (connectedUsers.length === 0) {
          onlineDiv.innerHTML = '<span style="color: #666;">No other users online</span>';
          document.getElementById('room-status').textContent = `${ROOM_ID} (1 user)`;
        } else {
          onlineDiv.innerHTML = connectedUsers.map(user => 
            `<span style="display: inline-block; margin-right: 10px; padding: 3px 8px; background: #28a745; color: white; border-radius: 3px; font-size: 12px;">
              ${user}
            </span>`
          ).join('');
          document.getElementById('room-status').textContent = `${ROOM_ID} (${connectedUsers.length + 1} users)`;
        }
        
        updateConnectionIndicator();
      }
      
      function updateConnectionIndicator(forceStatus = null) {
        const indicator = document.querySelector('.indicator-dot');
        const label = document.getElementById('connection-label');
        
        if (forceStatus) {
          indicator.className = `indicator-dot ${forceStatus}`;
          label.textContent = forceStatus === 'disconnected' ? 'Disconnected' : 'Connecting...';
          return;
        }
        
        const totalPossibleConnections = AUTHORIZED_USERS.filter(u => u !== myUsername).length;
        
        if (connections.size === totalPossibleConnections) {
          indicator.className = 'indicator-dot connected';
          label.textContent = 'All Connected';
          document.getElementById('connection-panel').classList.add('connected');
        } else if (connections.size > 0) {
          indicator.className = 'indicator-dot connecting';
          label.textContent = `Partial (${connections.size}/${totalPossibleConnections})`;
          document.getElementById('connection-panel').classList.remove('connected');
        } else {
          indicator.className = 'indicator-dot disconnected';
          label.textContent = 'Connecting...';
          document.getElementById('connection-panel').classList.remove('connected');
        }
      }
      
      async function handleRemoteData(data, fromUser) {
        if (data.type === 'time-sync') {
          handleTimeSync(data);
          return;
        }
        
        if (data.type === 'chat-message') {
          addChatMessage(data.username, data.message, data.timestamp, false);
          playNotificationSound();
          
          if (document.hidden) {
            showNotification('New Message', `${data.username}: ${data.message}`);
          }
          return;
        }
        
        if (data.type === 'source-changed') {
          console.log('Source change received:', data);
          await loadSource(data.sourceType, data.sourceIdentifier, data.fromUser);
          return;
        }
        
        isReceivingRemote = true;
        
        switch(data.type) {
          case 'play':
            if (player.paused) {
              if (Math.abs(player.currentTime - data.time) > 0.2) {
                player.currentTime = data.time;
              }
              player.play().catch(e => console.log('Play failed:', e));
              updateStatus(`${fromUser} started playback`);
            }
            break;
            
          case 'pause':
            if (!player.paused) {
              if (Math.abs(player.currentTime - data.time) > 0.2) {
                player.currentTime = data.time;
              }
              player.pause();
              updateStatus(`${fromUser} paused`);
            }
            break;
            
          case 'seek':
            const timeDiff = Math.abs(player.currentTime - data.time);
            if (timeDiff > 0.2) {
              player.currentTime = data.time;
              lastSentTime = data.time;
              updateStatus(`${fromUser} jumped to ${formatTime(data.time)}`);
            }
            break;
            
          case 'speed':
            if (player.speed !== data.rate) {
              player.speed = data.rate;
              updateStatus(`${fromUser} changed speed to ${data.rate}x`);
            }
            break;
            
          case 'video-loaded':
            updateStatus(`${fromUser} loaded: ${data.filename}`);
            document.getElementById('filename-display').textContent = `${fromUser}: ${data.filename}`;
            if (data.isPlaying) {
              player.currentTime = data.currentTime;
              player.play().catch(e => console.log('Play failed:', e));
            }
            break;
            
          case 'subtitle-loaded':
            console.log(`Received subtitle from ${fromUser}: ${data.filename}`);
            
            showNotification('Subtitle Shared', `${fromUser} shared subtitle:<br>${data.filename}<br><small style="opacity: 0.8;">Subtitle updated for everyone</small>`);
            
            const subtitleBlob = new Blob([data.content], { type: 'text/vtt' });
            currentSubtitleURL = URL.createObjectURL(subtitleBlob);
            
            updatePlayerSource();
            
            updateStatus(`${fromUser} shared subtitle: ${data.filename}`);
            document.getElementById('subtitle-info').textContent = `Subtitle: ${data.filename} (from ${fromUser})`;
            
            setTimeout(() => {
              player.captions.active = true;
            }, 500);
            break;
        }
        
        setTimeout(() => {
          isReceivingRemote = false;
        }, 50);
      }
      
      function sendToUser(conn, data) {
        if (conn.open) {
          conn.send(data);
        }
      }
      
      function sendToAll(data) {
        connections.forEach(conn => {
          sendToUser(conn, data);
        });
      }
      
      // PLAYER SYNC EVENT HANDLERS
      player.on('play', () => {
        if (!isReceivingRemote) {
          const state = 'play:' + player.currentTime;
          if (lastSentState !== state) {
            lastSentState = state;
            sendToAll({ type: 'play', time: player.currentTime });
          }
        }
      });
      
      player.on('pause', () => {
        if (!isReceivingRemote) {
          const state = 'pause:' + player.currentTime;
          if (lastSentState !== state) {
            lastSentState = state;
            sendToAll({ type: 'pause', time: player.currentTime });
          }
        }
      });
      
      player.on('seeked', () => {
        if (!isReceivingRemote) {
          const currentTime = player.currentTime;
          if (Math.abs(currentTime - lastSentTime) > 0.1) {
            lastSentTime = currentTime;
            sendToAll({ type: 'seek', time: currentTime });
          }
        }
      });
      
      player.on('ratechange', () => {
        if (!isReceivingRemote) {
          sendToAll({ type: 'speed', rate: player.speed });
        }
      });
      
      // Special handling for YouTube
      player.on('statechange', (event) => {
        if (currentSourceType === 'youtube') {
          console.log('YouTube state changed:', event.detail.code);
          // YouTube state codes: -1 unstarted, 0 ended, 1 playing, 2 paused, 3 buffering, 5 cued
          if (event.detail.code === 1 && !isReceivingRemote) { // Playing
            sendToAll({ type: 'play', time: player.currentTime });
          } else if (event.detail.code === 2 && !isReceivingRemote) { // Paused
            sendToAll({ type: 'pause', time: player.currentTime });
          }
        }
      });
      
      // Time sync functionality
      let syncInterval;
      function startTimeSync() {
        if (syncInterval) clearInterval(syncInterval);
        
        syncInterval = setInterval(() => {
          if (connections.size > 0 && !player.paused && !isReceivingRemote) {
            if (isHost) {
              sendToAll({ 
                type: 'time-sync', 
                time: player.currentTime,
                playing: true,
                sourceType: currentSourceType
              });
            }
          }
        }, 1000);
      }
      
      function handleTimeSync(data) {
        if (!isHost && data.playing && !player.paused) {
          const drift = Math.abs(player.currentTime - data.time);
          // Allow more drift for YouTube videos
          const maxDrift = (currentSourceType === 'youtube' || data.sourceType === 'youtube') ? 1.0 : 0.5;
          
          if (drift > maxDrift) {
            isReceivingRemote = true;
            player.currentTime = data.time;
            setTimeout(() => isReceivingRemote = false, 50);
          }
        }
      }
      
      // Helper functions
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }
      
      function updateStatus(message) {
        document.getElementById('status-text').textContent = message;
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Synced';
        }, 3000);
      }
      
      // Keyboard shortcut for toggling webcam focus in fullscreen
      document.addEventListener('keydown', (e) => {
        if (document.fullscreenElement && e.key === 'w' && !e.ctrlKey && !e.metaKey) {
          if (document.activeElement === chatInput) return;
          
          e.preventDefault();
          
          const currentWebcamHeight = parseInt(webcamContainer.style.height) || 150;
          const isWebcamFocused = currentWebcamHeight > window.innerHeight * 0.4;
          
          if (isWebcamFocused) {
            updateFullscreenLayout(150, true);
          } else {
            updateFullscreenLayout(window.innerHeight - 58, true);
          }
          
          showNotification('View Changed', isWebcamFocused ? 'Normal view' : 'Webcam focus mode', 1500);
        }
      });
      
      // Cleanup
      window.addEventListener('beforeunload', () => {
        clearTimeout(reconnectTimer);
        if (peer) {
          peer.destroy();
        }
      });
      
      // Initialize everything
      initializeAutoConnect();
      console.log('Enhanced Video Sync System initialized successfully');
    });
  </script>
</body>
</html>